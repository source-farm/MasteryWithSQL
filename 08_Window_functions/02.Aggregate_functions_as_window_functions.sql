-- Агрегатные функции также можно использовать и как оконные функции.

-- Запрос для вывода рядом с каждым фильмом средней продолжительности
-- всех фильмов, у которых такой же рейтинг как и текущего фильма:
select title,
       rating,
       length,
       -- Выражение "partition by rating" как бы создаёт некую виртуальную
       -- таблицу из строк, у которых такой же рейтинг как и текущей строки.
       -- Далее для этой таблицы вычисляется среднее значение поля length и
       -- добавляется в текущую строку.
       avg(length) over (partition by rating)
  from film;

-- Как мы уже видели в предыдущем уроке выражение в скобках после OVER может
-- содержать выражение ORDER BY, например, в примере выше можно было бы добавить
-- ORDER BY length. Здесь это не имеет смысла, т.к. находится среднее значение.
-- Кроме PARTITION BY и ORDER BY выражение в скобках после OVER может ещё
-- содержать так называемый оконный фрейм (window frame). При использовании чисто
-- оконных функций как rank и др., оконный фрейм не играет никакой роли, но фрейм
-- имеет значение при использовании агрегатных функций (count, sum, avg). Оконный
-- фрейм - это ещё более мелкое разбиение подокна, который был получен с помощью
-- PARTITION BY. Если есть выражение ORDER BY, то по-умолчанию оконный фрейм
-- охватывает область от начала текущей партиции (подокна) до текущей строки
-- включительно и вычисления производятся над этим оконным фреймом. Если выражения
-- ORDER BY нет, то оконный фрейм охватывает все строки партиции. Повторим ещё
-- раз, что оконный фрейм имеет смысл только при использовании агрегатных функций
-- как оконных; чисто оконные функции не работают с оконным фреймом.

-- Пример пустого окна:
select payment_date,
       amount,
       -- В скобках не указано никаких выражений. Поэтому sum(amount) вычисляется
       -- для всех строк таблицы.
       sum(amount) over ()
  from payment;

-- Вывод рядом с платежом клиента общей суммы денег, которые он потратил:
select customer_id,
       payment_date,
       amount,
       sum(amount) over (partition by customer_id)
  from payment;

-- Вывод рядом с платежом клиента суммы денег, которые он потратил на текущую дату:
select customer_id,
       payment_date,
       amount,
       -- Тут sum(amount) вычисляется над оконным фреймом, о котором мы говорили выше,
       -- т.к. в скобках после OVER есть выражение ORDER BY. Как мы уже говорили оконный
       -- фрейм охватывает область от начала партиции до текущей строки. Именно поэтому
       -- и получается вычисление денег, потраченных клиентом на текущую дату включительно.
       -- Т.е. для первой строки из партиции оконный фрейм состоит только из одной
       -- этой строки. Для второй строки фрейм состоит из двух строк - 1-й и 2-й. Для
       -- третьей - из 1-й, 2-й и 3-й и т.д.
       sum(amount) over (partition by customer_id
                         order by payment_date)
  from payment;

-- Оконный фрейм можно также указывать и явным образом. Следующий запрос делает то
-- же самое, что и верхний:
select customer_id,
       payment_date,
       amount,
       sum(amount) over (partition by customer_id
                         order by payment_date
                         rows between unbounded preceding and current row)
  from payment;

-- Отмена оконного фрейма, т.е. вывод общего количества денег, которые потратил клиент:
select customer_id,
       payment_date,
       amount,
       sum(amount) over (partition by customer_id
                         order by payment_date
                         rows between unbounded preceding and unbounded following)
  from payment;

-- Вывод рядом с платежом клиента среднего значения последних трёх платежей, включая текущий:
select customer_id,
       payment_date,
       amount,
       avg(amount) over (partition by customer_id
                         order by payment_date
                         rows between 2 preceding and current row)
  from payment;
