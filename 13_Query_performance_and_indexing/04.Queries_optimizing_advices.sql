-- Оптимизация запросов не является тривиальной задачей, иначе планировщик запрос PostgreSQL
-- сам справился бы с этим, т.к. он итак для любого запроса ищет сам оптимальный способ
-- выполнения. Вначале следует написать самый читабельный и понятный вариант запроса и только
-- если его производительность не очень высокая следует приступать к оптимизации. Оптимизация
-- зависит как от самого запроса так и от данных, с которыми работает этот запрос.

-- Советы по оптимизации:

-------------------------------------------------------------------------------
-- 1 --
-------------------------------------------------------------------------------
-- Можно попробовать выполнить запрос разными способами: с помощью JOIN'ов, подзапросов,
-- операторов для работы с множествами, оконными функциями и т.д. В общем случае нужно
-- стараться использовать как можно меньше подзапросов, заменив их JOIN'ами.

-- Для сравнения напишем три запроса, которые находят недостающие строки из таблицы
-- test.messages.
-- Сначала удалим несколько строк (эти строки и должны будут найти наши три запроса):
delete from test.messages
      where id in (11, 42, 128, 129, 100500, 100501, 999999);

-- Вариант 1 - связанный подзапрос:
select s.id
  from generate_series((select min(id) from test.messages), (select max(id) from test.messages)) as s(id)
 where not exists (select *
                     from test.messages as m
                    where m.id = s.id);

-- Вариант 2 - CTE:
with t as
(
    select id as current,
           lead(id) over (order by id) as next
      from test.messages
)
select current + 1 as missing_from,
       next - 1 as missing_to
  from t
 where next - current > 1;

-- Вариант 3 - операции с множествами:
(
select t.id
  from generate_series((select min(id) from test.messages), (select max(id) from test.messages)) as t(id)
)
except
(
select id
  from test.messages as m
);

-- С помощью EXPLAIN ANALYZE можно получить время выполнения всех трёх запросов:
--
--     Вариант 1 - 1183.961 мс
--     Вариант 2 - 619.752 мс
--     Вариант 3 - 959.981 мс
--
-- Т.е. самым лучшим оказался подход с использованием CTE.

-------------------------------------------------------------------------------
-- 2 --
-------------------------------------------------------------------------------
-- Создать индексы. Индексы могут привести к ускорению выполнения запроса в несколько раз.
-- Для нахождения столбцов, для которых нужно создать индекс, нужно попровать найти
-- последовательные сканирования (Seq Scan) с помощью EXPLAIN ANALYZE. Также можно
-- поиграться с разными типами индексов (GIN, BRIN и т.д.).

-------------------------------------------------------------------------------
-- 3 --
-------------------------------------------------------------------------------
-- Создать частичные индексы (partial index). Например,
--
--     create index on customer(email) where id = 1;
--
-- Если в таблице customer часто выполняется запрос по полю email с id = 1, то созданный
-- частичный индекс ускорит выполнение этого запроса.

-------------------------------------------------------------------------------
-- 4 --
-------------------------------------------------------------------------------
-- В PostgreSQL 11 и ниже CTE могут привести к блокировке применению оптимизаций
-- ("optimization fence", исправлено в PostgreSQL 12). Поэтому в этих версиях
-- может иметь смысл переписать запрос без использования CTE.

-------------------------------------------------------------------------------
-- 5 --
-------------------------------------------------------------------------------
-- Несколько более мелких советов:
--
--    1. Использовать JOIN вместо IN.
--    2. Использовать LEFT JOIN или NOT EXISTS вместо NOT IN.
--    3. Использовать FILTER вместо выражений CASE.
--    4. Постараться свести количество подзапросов к минимуму.
