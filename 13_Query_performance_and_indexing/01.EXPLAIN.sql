-- На скорость работы запроса влияет несколько параметров:
--
--     - железо (диск, ОЗУ, процессор)
--     - настройка PostgreSQL
--     - загрузка сервера БД (сколько соединений обрабатывается и т.д.)
--     - объём данных
--     - запрос - как он написан, использует ли индексы и т.д.

-- Сначала нам необходимо определить какие запросы работают медленно.
-- Это можно сделать либо вручную запуская скрипты и оценива их производительность
-- либо сбором логов с работающего сервера БД.

-- Предположим, что мы нашли медленный запрос. Чтобы узнать почему он работает
-- медленно необходимо изучить так называемый план запроса (query plan). Как будет
-- выполняться запрос решает часть сервера PostgreSQL, который называется планировщик
-- (planner) или оптимизатор (optimizer). Планировщик находит наилучший способ выполнить
-- то, что описано в запросе. План запроса - это подробный отчёт того как БД собирается
-- выполнить запрос - какие индексы будет использовать, порядок выполнения JOIN'ов,
-- как будут сканироваться таблицы и т.д. Понимание плана запроса может привести к
-- пониманию того почему запрос работает медленно.

-- План запроса можно получить с помощью ключевого слова EXPLAIN перед запросом:
explain
select *
  from actor
 where first_name = 'MARY';

-- Для этого запроса план запроса выглядит так:
/*
QUERY PLAN                                          |
----------------------------------------------------|
Seq Scan on actor  (cost=0.00..4.50 rows=2 width=25)|
  Filter: ((first_name)::text = 'MARY'::text)       |
*/

-- Если перед запросом стоит просто EXPLAIN, то сам этот запрос не выполняется.
-- Выполняется только формирование плана запроса - то что сделало бы БД, если бы
-- запрос был выполнен.
-- Чтобы получить план запроса и одновременно выполнить запрос нужно использовать
-- EXPLAIN ANALYZE:
explain analyze
select *
  from actor
 where first_name = 'MARY';
-- В результате мы получим более подробный план запроса:
/*
QUERY PLAN                                                                                    |
----------------------------------------------------------------------------------------------|
Seq Scan on actor  (cost=0.00..4.50 rows=2 width=25) (actual time=0.528..0.550 rows=2 loops=1)|
  Filter: ((first_name)::text = 'MARY'::text)                                                 |
  Rows Removed by Filter: 198                                                                 |
Planning Time: 0.047 ms                                                                       |
Execution Time: 0.562 ms                                                                      |
*/

-- Если при выполнении explain analyze происходит модификация БД, то лучше заключить его в блок транзакции.

-- Рассмотрим более подробно план запроса, который мы получили для первого запроса этого урока:
/*
QUERY PLAN                                          |
----------------------------------------------------|
Seq Scan on actor  (cost=0.00..4.50 rows=2 width=25)|
  Filter: ((first_name)::text = 'MARY'::text)       |
*/

-- "Seq Scan on actor" означает, что вся таблица actor должна быть прочитана из
-- диска в память и просканирована. Это считается очень медленной операцией и
-- использование индексов позволяет извлечь данные более эффективным образом.
-- "Filter: ((first_name)::text = 'MARY'::text)" обозначает, что во время
-- сканирования таблицы actor будет происходит фильтрация строк по полю first_name
-- - оно должно быть равно 'MARY'. Далее в скобках идёт число 0.00 - это стоимость
-- предварительных операций до выполнения шага "Seq Scan on actor", т.е.
-- выполнения вычитывания данных с диска и их сканирования.  Какой-либо единицы
-- измерения оно не имеет, просто чем больше это число тем хуже (также оно не
-- переносимо между разными машинами). 0.45 - это стоимость выполнения шага
-- "Seq Scan on actor"; тоже чем больше тем хуже. "rows=2" означает, что в
-- результате выполнения запроса ожидается получить две строки. Как PostgreSQL
-- может знать сколько будет получено строк, ведь просто EXPLAIN не выполняет
-- запрос. PostgreSQL для каждой таблицы создаёт таблицу с различной статистикой:
-- макс. и мин. значения каждого столбца, количество различных строк в каждом
-- столбце и т.д.  EXPLAIN обращается именно к этой таблице для оценки времени
-- выполнения, но это лишь оценка и для получения фактического времени выполнения
-- запроса нужно использовать EXPLAIN ANALYZE.  "width=25" означает, что каждая
-- строка результата будет в среднем размером 25 байт.  После выполнения EXPLAIN
-- ANALYZE в дополнение к просто ANALYZE мы получим следующую строку для нашего примера
--
--     (actual time=0.528..0.550 rows=2 loops=1)
--
-- Здесь в скобках указано уже фактическое время выполнения шага "Seq Scan on actor"
-- в мс: 0.528 - предварительные действия до выполнения шага, 0.550 - фактическое время
-- выполнения шага. "rows=2" означает, что были найдены две строки. "loops=1" обозначает
-- сколько раз был выполнен шаг. В нашем случае сканирование произошло один раз, поэтому
-- loops равен 1, но могут быть запросы где он больше 1. Также EXPLAIN ANALYZE показывает
-- время, которое ушло на само планирование и общее время выполнения запроса:
--
--     Planning Time: 0.047 ms                                                                       |
--     Execution Time: 0.562 ms
--
-- PostgreSQL кэширует как сам план запроса так и данные. Поэтому последующие выполнения
-- одного и того же EXPLAIN запроса может выполняться быстрее.
